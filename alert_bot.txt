
================================================================================
FILE: price_alert.py
================================================================================

#!/usr/bin/env python3
import ccxt
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os
from dotenv import load_dotenv
import argparse
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import json
import yaml
from pathlib import Path
import logging
import statistics # Added for volatility calculation

# Setup logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Ensure logs directory exists
log_dir = Path('logs')
log_dir.mkdir(exist_ok=True)
log_file_path = log_dir / 'alert_logs.log'

# File handler
fh = logging.FileHandler(log_file_path)
fh.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)

# Console handler
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
ch.setFormatter(formatter)
logger.addHandler(ch)

# Load environment variables
load_dotenv()

N_VOLATILITY_PERIODS = 14  # Number of periods for volatility calculation (e.g., stdev)
MIN_CANDLES_FOR_PCT_CHANGE = 2

class PriceAlert:
    def __init__(self, config_data: Dict[str, Any], main_loop_interval_seconds: int = 60):
        self.exchange = ccxt.coinbase()
        try:
            self.exchange.load_markets()
        except Exception as e:
            logger.error(f"Error loading markets: {e}. Price formatting might be affected.")

        self.config_data = config_data
        self.symbols = list(self.config_data.keys())
        if not self.symbols:
            logger.warning("No symbols found in the configuration data.")
        
        self.main_loop_interval_seconds = main_loop_interval_seconds
        
        self.ohlcv_data: Dict[str, Dict[str, List[list]]] = {symbol: {} for symbol in self.symbols}
        self.last_ohlcv_fetch_time: Dict[str, Dict[str, datetime]] = {symbol: {} for symbol in self.symbols}
        self.last_ticker_prices: Dict[str, float] = {}
        
        # Email configuration
        self.smtp_server = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
        self.smtp_port = int(os.getenv('SMTP_PORT', 587))
        self.smtp_username = os.getenv('SMTP_USERNAME')
        self.smtp_password = os.getenv('SMTP_PASSWORD')
        self.alert_email = os.getenv('ALERT_EMAIL')

        logger.info(f"PriceAlert initialized for symbols: {', '.join(self.symbols)}")
        logger.info(f"Main loop interval: {self.main_loop_interval_seconds} seconds")

    def _get_ccxt_timeframe(self, minutes: int) -> Optional[str]:
        """Converts minutes to ccxt timeframe string."""
        if minutes < 1:
            return None
        if minutes < 60:
            return f"{minutes}m"
        elif minutes < 1440: # Less than a day
            hours = minutes // 60
            return f"{hours}h"
        else: # Days
            days = minutes // 1440
            return f"{days}d"

    def _format_price(self, symbol: str, price: float) -> str:
        """Formats the price according to the symbol's precision."""
        try:
            # Get market precision from CCXT if available
            if symbol in self.exchange.markets:
                precision_info = self.exchange.markets[symbol].get('precision', {})
                price_precision = precision_info.get('price')
                
                if price_precision is not None:
                    # Handle float precision (e.g., 0.00000001)
                    if isinstance(price_precision, float):
                        decimal_places = len(format(price_precision, '.10f').split('.')[1].rstrip('0'))
                        return f"{price:.{decimal_places}f}"
                    # Handle integer precision (number of decimal places)
                    else:
                        return f"{price:.{int(price_precision)}f}"
                        
            # Fallbacks based on price value if no precision info
            if abs(price) > 0 and abs(price) < 0.001:  # Very small prices
                return f"{price:.8f}"
            return f"{price:.2f}"  # Default format
            
        except Exception as e:
            logger.error(f"Error formatting price for {symbol} ({price}): {e}. Defaulting to .2f")
            return f"{price:.2f}"

    def send_email_alert(self, message: str):
        """Send email alert"""
        if not all([self.smtp_username, self.smtp_password, self.alert_email]):
            logger.warning("Email configuration not complete. Skipping email alert.")
            return

        try:
            msg = MIMEMultipart()
            msg['From'] = self.smtp_username
            msg['To'] = self.alert_email
            msg['Subject'] = "Crypto Price Alert"
            
            msg.attach(MIMEText(message, 'plain'))
            
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.smtp_username, self.smtp_password)
            server.send_message(msg)
            server.quit()
            logger.info("Alert email sent successfully!")
        except Exception as e:
            logger.error(f"Failed to send email alert: {e}")

    def send_test_alert(self):
        """Send a test email to verify credentials"""
        test_message = f"Test Alert\\n\\nThis is a test message to verify your email configuration is working correctly.\\n\\nTimestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        logger.info("Sending test email...")
        self.send_email_alert(test_message)

    def check_percentage_change(self, symbol: str, current_price: float, alert_config: Dict[str, Any], ohlcv_candles: List[list]) -> Optional[str]:
        """Check for significant percentage changes using OHLCV data."""
        if alert_config.get('triggered_session', False):
            return None # Already triggered in this session

        required_candles = MIN_CANDLES_FOR_PCT_CHANGE
        if len(ohlcv_candles) < required_candles:
            logger.debug(f"Not enough candles for {symbol} {alert_config.get('timeframe')}m percentage change (need {required_candles}, got {len(ohlcv_candles)})")
            return None

        # OHLCV candles are [timestamp, open, high, low, close, volume]
        # Last candle (ohlcv_candles[-1]) is the current, possibly incomplete one.
        # Second to last candle (ohlcv_candles[-2]) is the most recent fully completed one.
        # Its closing price is our 'old_price'.
        old_price = ohlcv_candles[-2][4] # Index 4 is close price

        if old_price == 0: # Avoid division by zero
            logger.warning(f"Old price is zero for {symbol}, cannot calculate percentage change.")
            return None

        percentage_diff = ((current_price - old_price) / old_price) * 100
        target_percentage = alert_config['percentage']
        timeframe_minutes = alert_config['timeframe']

        # Check if absolute percentage change meets the threshold
        if abs(percentage_diff) >= target_percentage:
            direction = "risen" if percentage_diff > 0 else "fallen"
            message = (
                f"{symbol} has {direction} by {percentage_diff:.2f}% in the last {timeframe_minutes} minutes. "
                f"(From {self._format_price(symbol, old_price)} to {self._format_price(symbol, current_price)})"
            )
            alert_config['triggered_session'] = True # Mark as triggered for this session
            return message
        return None

    def check_volatility(self, symbol: str, current_price: float, alert_config: Dict[str, Any], ohlcv_candles: List[list]) -> Optional[str]:
        """Check for high volatility using OHLCV data (std dev of closing prices)."""
        if alert_config.get('triggered_session', False):
            return None # Already triggered in this session

        if len(ohlcv_candles) < N_VOLATILITY_PERIODS:
            logger.debug(f"Not enough candles for {symbol} {alert_config.get('timeframe')}m volatility (need {N_VOLATILITY_PERIODS}, got {len(ohlcv_candles)})")
            return None

        # Use closing prices of the last N_VOLATILITY_PERIODS candles
        relevant_candles = ohlcv_candles[-N_VOLATILITY_PERIODS:]
        closes = [c[4] for c in relevant_candles] # Index 4 is close price

        if not closes or len(closes) < 2: # statistics.stdev needs at least 2 data points
            logger.debug(f"Not enough closing prices for stdev calculation for {symbol}.")
            return None
        
        std_dev = statistics.stdev(closes)
        
        if current_price == 0: # Avoid division by zero
            logger.warning(f"Current price is zero for {symbol}, cannot calculate volatility percentage.")
            return None

        # Volatility as a percentage of the current price
        volatility_percentage = (std_dev / current_price) * 100
        target_threshold = alert_config['threshold']
        timeframe_minutes = alert_config['timeframe']

        if volatility_percentage >= target_threshold:
            message = (
                f"{symbol} shows high volatility of {volatility_percentage:.2f}% over the last ~{timeframe_minutes * N_VOLATILITY_PERIODS / 60:.1f} hours (based on {N_VOLATILITY_PERIODS} periods of {timeframe_minutes}m candles). "
                f"(StdDev: {self._format_price(symbol, std_dev)}, Current Price: {self._format_price(symbol, current_price)})"
            )
            # The timeframe description in the message can be a bit tricky if timeframe_minutes varies.
            # For now, this gives an idea of the total period length used for stdev calc.
            alert_config['triggered_session'] = True # Mark as triggered for this session
            return message
        return None

    def check_alerts(self, symbol: str, current_price: float):
        """Check if any price alerts have been triggered based on config_data."""
        symbol_config = self.config_data.get(symbol)
        if not symbol_config:
            return

        alerts_triggered_messages = []

        # 1. Price Level Alerts
        if 'price_levels' in symbol_config:
            for alert_conf in symbol_config['price_levels']:
                price_level = float(alert_conf['price'])
                condition = alert_conf['condition']
                # Basic check; consider adding state to prevent re-alerting immediately
                if condition == 'above' and current_price > price_level:
                    message = f"{symbol} is now above {self._format_price(symbol, price_level)} (Current: {self._format_price(symbol, current_price)})"
                    alerts_triggered_messages.append(message)
                elif condition == 'below' and current_price < price_level:
                    message = f"{symbol} is now below {self._format_price(symbol, price_level)} (Current: {self._format_price(symbol, current_price)})"
                    alerts_triggered_messages.append(message)
        
        # 2. Percentage Change Alerts (OHLCV based - Stage 2)
        if 'percentage_changes' in symbol_config:
            for alert_conf in symbol_config['percentage_changes']:
                # OHLCV fetching and checking logic will go here in Stage 2
                # For now, it will call the placeholder check_percentage_change
                timeframe_minutes = alert_conf.get('timeframe')
                ccxt_tf = self._get_ccxt_timeframe(timeframe_minutes) if timeframe_minutes else None
                if ccxt_tf and symbol in self.ohlcv_data and ccxt_tf in self.ohlcv_data[symbol]:
                    candles = self.ohlcv_data[symbol][ccxt_tf]
                    if candles:
                        msg = self.check_percentage_change(symbol, current_price, alert_conf, candles)
                        if msg: alerts_triggered_messages.append(msg)
                    else:
                        logger.debug(f"No OHLCV candles available for {symbol} {ccxt_tf} to check percentage_changes.")
                else:
                    logger.debug(f"OHLCV data not ready for {symbol} {ccxt_tf} for percentage_changes (or no timeframe specified).")

        # 3. Volatility Alerts (OHLCV based - Stage 2)
        if 'volatility' in symbol_config:
            for alert_conf in symbol_config['volatility']:
                # OHLCV fetching and checking logic will go here in Stage 2
                timeframe_minutes = alert_conf.get('timeframe')
                ccxt_tf = self._get_ccxt_timeframe(timeframe_minutes) if timeframe_minutes else None
                if ccxt_tf and symbol in self.ohlcv_data and ccxt_tf in self.ohlcv_data[symbol]:
                    candles = self.ohlcv_data[symbol][ccxt_tf]
                    if candles:
                        msg = self.check_volatility(symbol, current_price, alert_conf, candles)
                        if msg: alerts_triggered_messages.append(msg)
                    else:
                        logger.debug(f"No OHLCV candles available for {symbol} {ccxt_tf} to check volatility.")
                else:
                    logger.debug(f"OHLCV data not ready for {symbol} {ccxt_tf} for volatility (or no timeframe specified).")

        for msg in alerts_triggered_messages:
            logger.info(f"ALERT: {msg}") # Log the alert locally
            self.send_email_alert(msg)

    def _fetch_ohlcv_if_needed(self, symbol: str, alert_configs: List[Dict[str, Any]]):
        """Fetches OHLCV data for the symbol if required by any alert and if cooldown passed."""
        required_timeframes_minutes = set()
        for alert_conf in alert_configs:
            if 'timeframe' in alert_conf:
                required_timeframes_minutes.add(alert_conf['timeframe'])

        for tf_minutes in required_timeframes_minutes:
            ccxt_tf = self._get_ccxt_timeframe(tf_minutes)
            if not ccxt_tf: continue

            now = datetime.now()
            last_fetch = self.last_ohlcv_fetch_time.get(symbol, {}).get(ccxt_tf)
            # Fetch if never fetched, or if (time since last fetch >= timeframe duration)
            # Example: for a '5m' timeframe, fetch every 5 minutes.
            should_fetch = False
            if last_fetch is None:
                should_fetch = True
            else:
                if (now - last_fetch) >= timedelta(minutes=tf_minutes):
                    should_fetch = True
            
            if should_fetch:
                try:
                    # Determine number of candles. For now, a fixed number.
                    # For percentage change, 2 might be enough (current forming, last closed).
                    # For volatility, more might be needed (e.g., 20-50).
                    # Let's use a heuristic or make it configurable later.
                    limit = 50 # Default limit, can be refined per alert type
                    logger.info(f"Fetching {limit} OHLCV candles for {symbol} ({ccxt_tf})...")
                    candles = self.exchange.fetch_ohlcv(symbol, timeframe=ccxt_tf, limit=limit)
                    if symbol not in self.ohlcv_data: self.ohlcv_data[symbol] = {}
                    self.ohlcv_data[symbol][ccxt_tf] = candles
                    if symbol not in self.last_ohlcv_fetch_time: self.last_ohlcv_fetch_time[symbol] = {}
                    self.last_ohlcv_fetch_time[symbol][ccxt_tf] = now
                    logger.info(f"Fetched {len(candles)} OHLCV candles for {symbol} ({ccxt_tf}).")
                except Exception as e:
                    logger.error(f"Error fetching OHLCV for {symbol} ({ccxt_tf}): {e}")
                    # Ensure old data isn't used if fetch fails, or handle staleness
                    if symbol in self.ohlcv_data and ccxt_tf in self.ohlcv_data[symbol]:
                        del self.ohlcv_data[symbol][ccxt_tf] # Invalidate old data on error

    def run(self):
        """Main loop to fetch prices and check alerts"""
        logger.info(f"Starting price monitoring for {', '.join(self.symbols)}")
        logger.info("Press Ctrl+C to stop")
        
        if not self.symbols:
            logger.warning("No symbols to monitor. Exiting.")
            return

        while True:
            try:
                for symbol in self.symbols:
                    symbol_config = self.config_data.get(symbol)
                    if not symbol_config: continue

                    try:
                        # Fetch current ticker price
                        ticker = self.exchange.fetch_ticker(symbol)
                        current_price = ticker['last']
                        self.last_ticker_prices[symbol] = current_price
                        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        logger.info(f"[{timestamp}] {symbol}: {self._format_price(symbol, current_price)}")
                        
                        # Determine all alert configs that need OHLCV for this symbol
                        ohlcv_alert_configs = []
                        if 'percentage_changes' in symbol_config:
                            ohlcv_alert_configs.extend(symbol_config['percentage_changes'])
                        if 'volatility' in symbol_config:
                            ohlcv_alert_configs.extend(symbol_config['volatility'])
                        
                        if ohlcv_alert_configs:
                            self._fetch_ohlcv_if_needed(symbol, ohlcv_alert_configs)
                        
                        # Perform all checks for the symbol
                        self.check_alerts(symbol, current_price)
                    
                    except ccxt.NetworkError as e:
                        logger.error(f"Network error for {symbol}: {e}. Will retry.")
                    except ccxt.ExchangeError as e:
                        logger.error(f"Exchange error for {symbol}: {e}. Will retry.")
                    except Exception as e:
                        logger.error(f"Error processing symbol {symbol}: {e}")
                
                logger.debug(f"Main loop completed. Sleeping for {self.main_loop_interval_seconds}s.")
                time.sleep(self.main_loop_interval_seconds)
                
            except KeyboardInterrupt:
                logger.info("Monitoring stopped by user (Ctrl+C).")
                break
            except Exception as e:
                logger.error(f"Unhandled error in main loop: {e}", exc_info=True)
                time.sleep(60)  # Wait a minute before retrying

def create_example_config():
    """Create an example configuration file"""
    example_config = {
        'BTC/USD': {
            'price_levels': [
                {'price': 50000, 'condition': 'above'},
                {'price': 45000, 'condition': 'below'}
            ],
            'percentage_changes': [ # Example structure for future use
                {'percentage': 5, 'timeframe': 10} # 10 minutes
            ],
            'volatility': [ # Example structure for future use
                {'threshold': 2, 'timeframe': 5} # 5 minutes
            ]
        },
        'ETH/USD': {
            'price_levels': [
                {'price': 3000, 'condition': 'above'},
                {'price': 2500, 'condition': 'below'}
            ],
            'percentage_changes': [
                {'percentage': 7, 'timeframe': 15}
            ],
            'volatility': [
                {'threshold': 3, 'timeframe': 5}
            ]
        },
        'PEPE/USD': { # Example for high precision
            'price_levels': [
                {'price': 0.00001700, 'condition': 'above'},
                {'price': 0.00001200, 'condition': 'below'}
            ]
        }
    }
    
    config_path = Path('sentinel/alert_bot/alerts_config.yaml')
    with open(config_path, 'w') as f:
        yaml.dump(example_config, f, default_flow_style=False)
    logger.info(f"Created example configuration file at {config_path}")

def main():
    parser = argparse.ArgumentParser(description='Crypto Price Alert Monitor - Config Driven')
    parser.add_argument('--config', type=str, default='scripts/alerts_config.yaml', help='Path to YAML configuration file (default: scripts/alerts_config.yaml)')
    parser.add_argument('--main-loop-interval', type=int, default=60, help='Main loop check interval in seconds (default: 60)')
    parser.add_argument('--create-config', action='store_true', help='Create an example configuration file and exit')
    parser.add_argument('--test-email', action='store_true', help='Send a test email to verify credentials and exit')
    
    args = parser.parse_args()
    
    if args.create_config:
        create_example_config()
        return

    config_data = None
    try:
        with open(args.config, 'r') as f:
            config_data = yaml.safe_load(f)
        if not isinstance(config_data, dict):
            logger.error(f"Error: Config file {args.config} is not a valid YAML dictionary. Exiting.")
            return
        if not config_data:
            logger.error(f"Error: Config file {args.config} is empty or invalid. Exiting.")
            return
            
    except FileNotFoundError:
        logger.error(f"Error: Config file '{args.config}' not found. Use --create-config to generate an example. Exiting.")
        return
    except Exception as e:
        logger.error(f"Error reading or parsing config file {args.config}: {e}. Exiting.")
        return
    
    # Initialize PriceAlert with the loaded config_data
    monitor = PriceAlert(config_data=config_data, main_loop_interval_seconds=args.main_loop_interval)
    
    if args.test_email:
        monitor.send_test_alert()
        return
    
    monitor.run()

if __name__ == "__main__":
    main() 


================================================================================
FILE: main.py
================================================================================

#!/usr/bin/env python3
import argparse
import logging
import time
import os
import sys
from pathlib import Path
from typing import Optional

from config.loader import load_config
from rules.engine import RuleEngine
from fetcher.ccxt_fetcher import CCXTFetcher
from notifier.email_notifier import EmailNotifier
from notifier.console_notifier import ConsoleNotifier

# Setup logging
logger = logging.getLogger("price_alert")

def setup_logging(log_level: str = "INFO") -> None:
    """
    Set up logging configuration
    
    Args:
        log_level: Logging level (INFO, DEBUG, etc.)
    """
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    
    # Ensure logs directory exists
    log_dir = Path('logs')
    log_dir.mkdir(exist_ok=True)
    log_file_path = log_dir / 'alert_logs.log'
    
    # Configure logging
    logging.basicConfig(
        level=numeric_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file_path),
            logging.StreamHandler()
        ]
    )

def main():
    """Main entry point for price alert bot"""
    parser = argparse.ArgumentParser(description='Crypto Price Alert Bot')
    parser.add_argument('--config', type=str, default='sentinel/alert_bot/config/alerts_config.yaml', 
                      help='Path to YAML configuration file')
    parser.add_argument('--interval', type=int, default=60, 
                      help='Main loop check interval in seconds (default: 60)')
    parser.add_argument('--log-level', type=str, default='INFO', 
                      choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                      help='Logging level')
    parser.add_argument('--test-email', action='store_true', 
                      help='Send a test email and exit')
    parser.add_argument('--exchange', type=str, default='coinbase',
                      help='CCXT exchange ID to use (default: coinbase)')
    
    args = parser.parse_args()
    
    # Setup logging
    setup_logging(args.log_level)
    
    try:
        # Load configuration
        logger.info(f"Loading config from {args.config}")
        config = load_config(args.config)
        
        # Initialize components
        fetcher = CCXTFetcher(exchange_id=args.exchange)
        rule_engine = RuleEngine(config)
        
        # Set up notifiers
        console_notifier = ConsoleNotifier()
        email_notifier = EmailNotifier(use_env_vars=True)
        
        if args.test_email:
            logger.info("Sending test email...")
            email_notifier.send_test_notification()
            return
        
        # Main loop
        logger.info(f"Starting price monitoring for {', '.join(rule_engine.get_symbols())}")
        logger.info(f"Check interval: {args.interval} seconds")
        logger.info("Press Ctrl+C to stop")
        
        while True:
            try:
                for symbol in rule_engine.get_symbols():
                    try:
                        # Fetch current price
                        current_price = fetcher.fetch_current_price(symbol)
                        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
                        logger.info(f"[{timestamp}] {symbol}: {fetcher.format_price(symbol, current_price)}")
                        
                        # Evaluate rules and collect alert messages
                        alert_messages = rule_engine.evaluate_symbol(symbol, current_price)
                        
                        # Send notifications if there are any alerts
                        if alert_messages:
                            console_notifier.send_notification(alert_messages)
                            email_notifier.send_notification(alert_messages)
                            
                    except Exception as e:
                        logger.error(f"Error processing symbol {symbol}: {e}")
                
                # Sleep until next check
                logger.debug(f"Main loop completed. Sleeping for {args.interval}s.")
                time.sleep(args.interval)
                
            except KeyboardInterrupt:
                logger.info("Monitoring stopped by user (Ctrl+C).")
                break
            except Exception as e:
                logger.error(f"Unhandled error in main loop: {e}", exc_info=True)
                time.sleep(60)  # Wait a minute before retrying
                
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()



================================================================================
FILE: notifier/email_notifier.py
================================================================================

#!/usr/bin/env python3
import os
import smtplib
import logging
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import List, Optional
from datetime import datetime

from .base import BaseNotifier

logger = logging.getLogger(__name__)

class EmailNotifier(BaseNotifier):
    """
    Notifier that sends alerts via email
    """
    
    def __init__(self, 
                 smtp_server: Optional[str] = None,
                 smtp_port: Optional[int] = None,
                 smtp_username: Optional[str] = None,
                 smtp_password: Optional[str] = None,
                 recipient_email: Optional[str] = None,
                 use_env_vars: bool = True):
        """
        Initialize the email notifier
        
        Args:
            smtp_server: SMTP server address
            smtp_port: SMTP server port
            smtp_username: SMTP username/email
            smtp_password: SMTP password
            recipient_email: Email to send alerts to
            use_env_vars: Whether to load config from environment variables
        """
        # Set up from parameters
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.smtp_username = smtp_username
        self.smtp_password = smtp_password
        self.recipient_email = recipient_email
        
        # Override with environment variables if requested
        if use_env_vars:
            self.smtp_server = os.getenv('SMTP_SERVER', self.smtp_server or 'smtp.gmail.com')
            self.smtp_port = int(os.getenv('SMTP_PORT', self.smtp_port or 587))
            self.smtp_username = os.getenv('SMTP_USERNAME', self.smtp_username)
            self.smtp_password = os.getenv('SMTP_PASSWORD', self.smtp_password)
            self.recipient_email = os.getenv('ALERT_EMAIL', self.recipient_email)
        
        self._check_config()
    
    def _check_config(self) -> None:
        """Check if the email configuration is complete"""
        missing = []
        if not self.smtp_server:
            missing.append("SMTP server")
        if not self.smtp_port:
            missing.append("SMTP port")
        if not self.smtp_username:
            missing.append("SMTP username/email")
        if not self.smtp_password:
            missing.append("SMTP password")
        if not self.recipient_email:
            missing.append("recipient email")
            
        if missing:
            logger.warning(f"Email notifier is missing configuration: {', '.join(missing)}")
            logger.warning("Email alerts will not be sent until configuration is complete")
    
    def send_notification(self, messages: List[str]) -> bool:
        """
        Send email notification with the given alert messages
        
        Args:
            messages: List of alert messages to include
            
        Returns:
            True if email was sent successfully, False otherwise
        """
        if not messages:
            return True  # Nothing to send
            
        if not all([self.smtp_server, self.smtp_port, self.smtp_username, 
                   self.smtp_password, self.recipient_email]):
            logger.warning("Email configuration incomplete. Skipping notification.")
            return False
            
        try:
            msg = MIMEMultipart()
            msg['From'] = self.smtp_username
            msg['To'] = self.recipient_email
            msg['Subject'] = f"Crypto Price Alert - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            
            body = "\n\n".join(messages)
            msg.attach(MIMEText(body, 'plain'))
            
            # Connect to SMTP server
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.smtp_username, self.smtp_password)
            
            # Send email
            server.send_message(msg)
            server.quit()
            
            logger.info(f"Sent {len(messages)} alert(s) to {self.recipient_email}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email alert: {e}")
            return False
    
    def send_test_notification(self) -> bool:
        """
        Send a test email to verify configuration
        
        Returns:
            True if sent successfully, False otherwise
        """
        test_message = (
            f"Test Alert\n\n"
            f"This is a test message to verify your email configuration is working correctly.\n\n"
            f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        )
        logger.info("Sending test email...")
        return self.send_notification([test_message]) 


================================================================================
FILE: notifier/__init__.py
================================================================================

from .base import BaseNotifier
from .email_notifier import EmailNotifier
from .console_notifier import ConsoleNotifier

__all__ = ["BaseNotifier", "EmailNotifier", "ConsoleNotifier"]



================================================================================
FILE: notifier/base.py
================================================================================

#!/usr/bin/env python3
from abc import ABC, abstractmethod
from typing import List

class BaseNotifier(ABC):
    """
    Abstract base class for all alert notifiers
    """
    
    @abstractmethod
    def send_notification(self, messages: List[str]) -> bool:
        """
        Send notifications with the given messages
        
        Args:
            messages: List of alert messages to send
            
        Returns:
            True if notification was sent successfully, False otherwise
        """
        pass 


================================================================================
FILE: notifier/console_notifier.py
================================================================================

#!/usr/bin/env python3
import logging
from typing import List
from datetime import datetime

from .base import BaseNotifier

logger = logging.getLogger(__name__)

class ConsoleNotifier(BaseNotifier):
    """
    Simple notifier that outputs alerts to the console
    Useful for testing and development
    """
    
    def __init__(self, log_level: int = logging.INFO):
        """
        Initialize console notifier
        
        Args:
            log_level: Logging level to use for notifications
        """
        self.log_level = log_level
    
    def send_notification(self, messages: List[str]) -> bool:
        """
        Log alert messages to the console
        
        Args:
            messages: List of alert messages
            
        Returns:
            Always returns True
        """
        if not messages:
            return True  # Nothing to send
            
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        logger.log(self.log_level, f"=== PRICE ALERTS [{timestamp}] ===")
        for message in messages:
            logger.log(self.log_level, message)
        logger.log(self.log_level, "=" * 30)
        
        return True
    
    def send_test_notification(self) -> bool:
        """Send a test notification"""
        test_message = "This is a test alert notification."
        return self.send_notification([test_message]) 


================================================================================
FILE: config/__init__.py
================================================================================




================================================================================
FILE: config/loader.py
================================================================================

#!/usr/bin/env python3
from typing import List, Dict, Optional, Literal, Any, Union
from datetime import timedelta
from pathlib import Path
import logging
import yaml
from pydantic import BaseModel, Field, validator, root_validator

logger = logging.getLogger(__name__)

class PriceLevelRule(BaseModel):
    """Rule that triggers when price crosses above/below a specified level"""
    price: float
    condition: Literal['above', 'below']
    cooldown: int = Field(default=300, description="Seconds before this alert can trigger again")
    
    @validator('price')
    def price_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Price must be positive')
        return v
    
    @validator('cooldown')
    def cooldown_must_be_positive(cls, v):
        if v < 0:
            raise ValueError('Cooldown must be non-negative')
        return v

class PercentageChangeRule(BaseModel):
    """Rule that triggers when price changes by X% within specified timeframe"""
    percentage: float
    timeframe: int = Field(description="Timeframe in minutes")
    cooldown: int = Field(default=1800, description="Seconds before this alert can trigger again")
    
    @validator('percentage')
    def percentage_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Percentage must be positive')
        return v
    
    @validator('timeframe')
    def timeframe_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Timeframe must be positive')
        return v

class VolatilityRule(BaseModel):
    """Rule that triggers when price volatility exceeds threshold within timeframe"""
    threshold: float
    timeframe: int = Field(description="Timeframe in minutes")
    cooldown: int = Field(default=3600, description="Seconds before this alert can trigger again")
    
    @validator('threshold')
    def threshold_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Threshold must be positive')
        return v
    
    @validator('timeframe')
    def timeframe_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Timeframe must be positive')
        return v

class SymbolConfig(BaseModel):
    """Configuration for a single trading symbol"""
    price_levels: List[PriceLevelRule] = Field(default_factory=list)
    percentage_changes: List[PercentageChangeRule] = Field(default_factory=list)
    volatility: List[VolatilityRule] = Field(default_factory=list)
    
    @root_validator
    def at_least_one_rule(cls, values):
        """Ensure there's at least one rule defined"""
        has_rules = (
            len(values.get('price_levels', [])) > 0 or
            len(values.get('percentage_changes', [])) > 0 or
            len(values.get('volatility', [])) > 0
        )
        if not has_rules:
            raise ValueError('At least one rule type must be defined for the symbol')
        return values

class AlertConfig(BaseModel):
    """Root configuration object with all symbols and their rules"""
    symbols: Dict[str, SymbolConfig]
    
    # Custom constructor to translate from the flat YAML format to our nested structure
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AlertConfig':
        """Convert from flat dict of symbols to nested structure"""
        return cls(symbols={symbol: SymbolConfig(**config) for symbol, config in data.items()})

def load_config(config_path: Union[str, Path]) -> AlertConfig:
    """
    Load and validate the alert configuration from a YAML file
    
    Args:
        config_path: Path to the YAML configuration file
        
    Returns:
        Validated AlertConfig object
        
    Raises:
        FileNotFoundError: If config file doesn't exist
        ValidationError: If config doesn't match the expected schema
        Exception: Other parsing/loading errors
    """
    config_path = Path(config_path)
    
    if not config_path.exists():
        raise FileNotFoundError(f"Config file not found: {config_path}")
    
    try:
        with open(config_path, 'r') as f:
            raw_config = yaml.safe_load(f)
        
        if not isinstance(raw_config, dict):
            raise ValueError(f"Config must be a dictionary, got {type(raw_config)}")
        
        # Parse the config through our Pydantic model for validation
        config = AlertConfig.from_dict(raw_config)
        
        logger.info(f"Successfully loaded config with {len(config.symbols)} symbols")
        return config
        
    except Exception as e:
        logger.error(f"Failed to load config from {config_path}: {e}")
        raise

if __name__ == "__main__":
    # Example usage
    import sys
    logging.basicConfig(level=logging.INFO)
    
    if len(sys.argv) > 1:
        config_file = sys.argv[1]
    else:
        config_file = "alerts_config.yaml"
    
    try:
        config = load_config(config_file)
        print(f"Loaded config with {len(config.symbols)} symbols")
        for symbol, symbol_config in config.symbols.items():
            print(f"\n{symbol}:")
            if symbol_config.price_levels:
                print(f"  Price Levels: {len(symbol_config.price_levels)}")
            if symbol_config.percentage_changes:
                print(f"  Percentage Changes: {len(symbol_config.percentage_changes)}")
            if symbol_config.volatility:
                print(f"  Volatility Rules: {len(symbol_config.volatility)}")
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1) 


================================================================================
FILE: fetcher/__init__.py
================================================================================

from .ccxt_fetcher import CCXTFetcher

__all__ = ["CCXTFetcher"]



================================================================================
FILE: fetcher/ccxt_fetcher.py
================================================================================

#!/usr/bin/env python3
import ccxt
import logging
import time
from typing import Dict, List, Optional, Any, Union
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class CCXTFetcher:
    """
    Data fetcher using CCXT library for exchange data
    """
    
    def __init__(self, 
                 exchange_id: str = 'coinbase',
                 rate_limit_sleep: float = 1.0):
        """
        Initialize CCXT fetcher
        
        Args:
            exchange_id: CCXT exchange ID to use
            rate_limit_sleep: Sleep time between API requests to avoid rate limits
        """
        self.exchange_id = exchange_id
        self.rate_limit_sleep = rate_limit_sleep
        self.exchange = getattr(ccxt, exchange_id)()
        
        # Cache for market info
        self.markets = {}
        self.last_ticker_prices: Dict[str, Dict[str, Any]] = {}
        self.ohlcv_data: Dict[str, Dict[str, List[list]]] = {}
        self.last_ohlcv_fetch_time: Dict[str, Dict[str, datetime]] = {}
        
        # Try to load exchange markets
        try:
            self.exchange.load_markets()
            self.markets = self.exchange.markets
            logger.info(f"Loaded {len(self.markets)} markets from {exchange_id}")
        except Exception as e:
            logger.error(f"Error loading markets from {exchange_id}: {e}")
    
    def get_supported_symbols(self) -> List[str]:
        """Get list of supported trading symbols"""
        return list(self.markets.keys())
    
    def fetch_ticker(self, symbol: str) -> Dict[str, Any]:
        """
        Fetch current ticker data for symbol
        
        Args:
            symbol: Trading symbol (e.g., BTC/USD)
            
        Returns:
            Ticker data dictionary with at least 'last' price
            
        Raises:
            Exception if fetch fails
        """
        try:
            ticker = self.exchange.fetch_ticker(symbol)
            self.last_ticker_prices[symbol] = ticker
            time.sleep(self.rate_limit_sleep)  # Avoid rate limits
            logger.debug(f"Fetched ticker for {symbol}: {ticker['last']}")
            return ticker
        except Exception as e:
            logger.error(f"Error fetching ticker for {symbol}: {e}")
            raise
    
    def fetch_current_price(self, symbol: str) -> float:
        """
        Fetch just the current price for a symbol
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Current price
            
        Raises:
            Exception if fetch fails
        """
        ticker = self.fetch_ticker(symbol)
        return ticker['last']
    
    def _get_ccxt_timeframe(self, minutes: int) -> Optional[str]:
        """
        Convert minutes to CCXT timeframe string
        
        Args:
            minutes: Timeframe in minutes
            
        Returns:
            CCXT timeframe string or None if invalid
        """
        if minutes < 1:
            return None
        if minutes < 60:
            return f"{minutes}m"
        elif minutes < 1440:  # Less than a day
            hours = minutes // 60
            return f"{hours}h"
        else:  # Days
            days = minutes // 1440
            return f"{days}d"
    
    def fetch_ohlcv(self, symbol: str, timeframe_minutes: int, limit: int = 50) -> List[list]:
        """
        Fetch OHLCV (candle) data for a symbol
        
        Args:
            symbol: Trading symbol
            timeframe_minutes: Timeframe in minutes
            limit: Number of candles to fetch
            
        Returns:
            List of OHLCV candles [timestamp, open, high, low, close, volume]
            
        Raises:
            Exception if fetch fails
        """
        ccxt_tf = self._get_ccxt_timeframe(timeframe_minutes)
        if not ccxt_tf:
            raise ValueError(f"Invalid timeframe: {timeframe_minutes} minutes")
        
        try:
            # Create nested dictionaries if they don't exist
            if symbol not in self.ohlcv_data:
                self.ohlcv_data[symbol] = {}
            if symbol not in self.last_ohlcv_fetch_time:
                self.last_ohlcv_fetch_time[symbol] = {}
                
            candles = self.exchange.fetch_ohlcv(symbol, timeframe=ccxt_tf, limit=limit)
            self.ohlcv_data[symbol][ccxt_tf] = candles
            self.last_ohlcv_fetch_time[symbol][ccxt_tf] = datetime.now()
            
            time.sleep(self.rate_limit_sleep)  # Avoid rate limits
            
            logger.debug(f"Fetched {len(candles)} OHLCV candles for {symbol} ({ccxt_tf})")
            return candles
            
        except Exception as e:
            logger.error(f"Error fetching OHLCV for {symbol} ({ccxt_tf}): {e}")
            raise
    
    def format_price(self, symbol: str, price: float) -> str:
        """
        Format price with appropriate precision for the symbol
        
        Args:
            symbol: Trading symbol
            price: Price to format
            
        Returns:
            Formatted price string
        """
        try:
            # Get market precision from CCXT if available
            if symbol in self.markets:
                precision_info = self.markets[symbol].get('precision', {})
                price_precision = precision_info.get('price')
                
                if price_precision is not None:
                    # Handle float precision (e.g., 0.00000001)
                    if isinstance(price_precision, float):
                        decimal_places = len(format(price_precision, '.10f').split('.')[1].rstrip('0'))
                        return f"{price:.{decimal_places}f}"
                    # Handle integer precision (number of decimal places)
                    else:
                        return f"{price:.{int(price_precision)}f}"
                        
            # Fallbacks based on price value if no precision info
            if abs(price) > 0 and abs(price) < 0.001:  # Very small prices
                return f"{price:.8f}"
            return f"{price:.2f}"  # Default format
            
        except Exception as e:
            logger.error(f"Error formatting price for {symbol} ({price}): {e}. Defaulting to .2f")
            return f"{price:.2f}" 


================================================================================
FILE: state/__init__.py
================================================================================




================================================================================
FILE: state/manager.py
================================================================================

#!/usr/bin/env python3
from typing import Dict, Optional, Tuple, Any
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class StateManager:
    """
    Manages the state of alert rules, tracking when they were last triggered
    and enforcing cooldown periods.
    """
    
    def __init__(self):
        # Structure: {symbol: {rule_id: last_triggered_timestamp}}
        self._state: Dict[str, Dict[str, datetime]] = {}
    
    def register_symbol(self, symbol: str) -> None:
        """
        Register a new symbol to track
        """
        if symbol not in self._state:
            self._state[symbol] = {}
            logger.debug(f"Registered symbol {symbol} for state tracking")
    
    def can_trigger(self, symbol: str, rule_id: str, cooldown_seconds: int) -> bool:
        """
        Check if a rule can trigger based on its cooldown period
        
        Args:
            symbol: Trading symbol (e.g., BTC/USD)
            rule_id: Unique identifier for the rule
            cooldown_seconds: Seconds that must pass before the rule can trigger again
            
        Returns:
            True if enough time has passed since the last trigger
        """
        self.register_symbol(symbol)
        
        if rule_id not in self._state[symbol]:
            return True  # Never triggered before
        
        last_triggered = self._state[symbol][rule_id]
        cooldown = timedelta(seconds=cooldown_seconds)
        now = datetime.now()
        
        # Check if cooldown has passed
        return (now - last_triggered) >= cooldown
    
    def mark_triggered(self, symbol: str, rule_id: str) -> None:
        """
        Mark a rule as triggered at the current time
        
        Args:
            symbol: Trading symbol
            rule_id: Unique identifier for the rule
        """
        self.register_symbol(symbol)
        self._state[symbol][rule_id] = datetime.now()
        logger.debug(f"Rule {rule_id} for {symbol} marked as triggered")
    
    def get_last_triggered(self, symbol: str, rule_id: str) -> Optional[datetime]:
        """
        Get when a rule was last triggered
        
        Args:
            symbol: Trading symbol
            rule_id: Unique identifier for the rule
            
        Returns:
            Timestamp when the rule was last triggered, or None if never triggered
        """
        self.register_symbol(symbol)
        return self._state[symbol].get(rule_id)
    
    def get_symbols(self) -> list:
        """Get list of registered symbols"""
        return list(self._state.keys())
    
    def reset_symbol(self, symbol: str) -> None:
        """
        Reset all rule states for a symbol
        
        Args:
            symbol: Trading symbol to reset
        """
        if symbol in self._state:
            self._state[symbol] = {}
            logger.info(f"Reset state for symbol {symbol}")
    
    def reset_all(self) -> None:
        """Reset all state data"""
        self._state = {}
        logger.info("Reset all state data")
    
    def __repr__(self) -> str:
        counts = {symbol: len(rules) for symbol, rules in self._state.items()}
        return f"StateManager(symbols={len(counts)}, rule_counts={counts})" 


================================================================================
FILE: rules/__init__.py
================================================================================

from .base import AlertRule
from .price_level import PriceLevelRule
from .engine import RuleEngine

__all__ = ["AlertRule", "PriceLevelRule", "RuleEngine"]



================================================================================
FILE: rules/engine.py
================================================================================

#!/usr/bin/env python3
from typing import Dict, List, Any, Optional
import logging
from pathlib import Path

from ..config.loader import AlertConfig, load_config
from ..state.manager import StateManager
from .base import AlertRule
from .price_level import PriceLevelRule
# We'll add these imports later when we implement these rule types
# from .percentage_change import PercentageChangeRule
# from .volatility import VolatilityRule

logger = logging.getLogger(__name__)

class RuleEngine:
    """
    Manages and evaluates all alert rules across all symbols
    """
    
    def __init__(self, config_or_path: Any):
        """
        Initialize rule engine from config
        
        Args:
            config_or_path: Either AlertConfig object or path to config file
        """
        self.state_manager = StateManager()
        self.rules: Dict[str, List[AlertRule]] = {}  # {symbol: [rule1, rule2, ...]}
        
        if isinstance(config_or_path, (str, Path)):
            self.config = load_config(config_or_path)
        else:
            self.config = config_or_path
            
        self._initialize_rules()
        
    def _initialize_rules(self) -> None:
        """
        Initialize all rules from the config
        """
        for symbol, symbol_config in self.config.symbols.items():
            if symbol not in self.rules:
                self.rules[symbol] = []
                
            # Price level rules
            for rule_config in symbol_config.price_levels:
                rule = PriceLevelRule(symbol, rule_config.dict())
                self.rules[symbol].append(rule)
                
            # Percentage change rules - will implement later
            # for rule_config in symbol_config.percentage_changes:
            #     rule = PercentageChangeRule(symbol, rule_config.dict())
            #     self.rules[symbol].append(rule)
                
            # Volatility rules - will implement later
            # for rule_config in symbol_config.volatility:
            #     rule = VolatilityRule(symbol, rule_config.dict())
            #     self.rules[symbol].append(rule)
                
            logger.info(f"Initialized {len(self.rules[symbol])} rules for {symbol}")
    
    def get_symbols(self) -> List[str]:
        """Get all symbols with rules"""
        return list(self.rules.keys())
    
    def get_rules_for_symbol(self, symbol: str) -> List[AlertRule]:
        """Get all rules for a specific symbol"""
        return self.rules.get(symbol, [])
    
    def evaluate_symbol(self, symbol: str, current_price: float, 
                        extra_data: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Evaluate all rules for a symbol with the current price
        
        Args:
            symbol: Trading symbol
            current_price: Current price
            extra_data: Additional data needed for evaluation (OHLCV, etc.)
            
        Returns:
            List of alert messages generated
        """
        if symbol not in self.rules:
            logger.warning(f"No rules defined for {symbol}")
            return []
            
        alert_messages = []
        extra_data = extra_data or {}
        
        for rule in self.rules[symbol]:
            try:
                message = rule.evaluate(current_price, self.state_manager, extra_data)
                if message:
                    alert_messages.append(message)
            except Exception as e:
                logger.error(f"Error evaluating rule {rule.rule_id} for {symbol}: {e}")
                
        return alert_messages
    
    def reload(self, config_or_path: Any) -> None:
        """
        Reload rules from a new config
        
        Args:
            config_or_path: New config or path to config file
        """
        if isinstance(config_or_path, (str, Path)):
            self.config = load_config(config_or_path)
        else:
            self.config = config_or_path
            
        # Clear existing rules
        self.rules = {}
        # Load new rules
        self._initialize_rules()
        logger.info(f"Reloaded rules - now tracking {len(self.rules)} symbols")
        
    def __repr__(self) -> str:
        rule_counts = {symbol: len(rules) for symbol, rules in self.rules.items()}
        total_rules = sum(rule_counts.values())
        return f"RuleEngine(symbols={len(self.rules)}, total_rules={total_rules})" 


================================================================================
FILE: rules/price_level.py
================================================================================

#!/usr/bin/env python3
from typing import Optional, Dict, Any
import logging
from .base import AlertRule

logger = logging.getLogger(__name__)

class PriceLevelRule(AlertRule):
    """
    Rule that triggers when price crosses above or below a specified level
    """
    
    def __init__(self, symbol: str, config: Dict[str, Any]):
        """
        Initialize a price level rule
        
        Args:
            symbol: Trading symbol this rule applies to
            config: Configuration with price and condition
        """
        super().__init__(symbol, "price_level", config)
        self.price_level = float(config["price"])
        self.condition = config["condition"]  # 'above' or 'below'
        
        if self.condition not in ["above", "below"]:
            raise ValueError(f"Invalid condition '{self.condition}' - must be 'above' or 'below'")
        
        # More descriptive rule_id
        self.rule_id = f"price_level_{self.condition}_{self.price_level}_{self.symbol}"
        
        logger.debug(f"Created {self.condition} {self.price_level} rule for {symbol}")
    
    def evaluate(self, current_price: float, state_manager, extra_data=None) -> Optional[str]:
        """
        Check if price has crossed the specified level
        
        Args:
            current_price: Current price of the symbol
            state_manager: StateManager for tracking rule state
            extra_data: Not used for this rule type
            
        Returns:
            Alert message if triggered, None otherwise
        """
        if not state_manager.can_trigger(self.symbol, self.rule_id, self.cooldown_seconds):
            return None  # Still in cooldown period
        
        triggered = False
        
        if self.condition == "above" and current_price > self.price_level:
            triggered = True
            message = (
                f"{self.symbol} is now above {self.format_price(self.price_level)} "
                f"(Current: {self.format_price(current_price)})"
            )
        elif self.condition == "below" and current_price < self.price_level:
            triggered = True
            message = (
                f"{self.symbol} is now below {self.format_price(self.price_level)} "
                f"(Current: {self.format_price(current_price)})"
            )
        
        if triggered:
            state_manager.mark_triggered(self.symbol, self.rule_id)
            logger.info(f"TRIGGERED: {message}")
            return message
            
        return None 


================================================================================
FILE: rules/base.py
================================================================================

#!/usr/bin/env python3
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
import uuid

class AlertRule(ABC):
    """
    Abstract base class for all alert rules.
    
    Each rule implements its own logic for when to trigger an alert
    based on price data and other inputs.
    """
    
    def __init__(self, symbol: str, rule_type: str, config: Dict[str, Any]):
        """
        Initialize a new alert rule
        
        Args:
            symbol: Trading symbol this rule applies to (e.g., BTC/USD)
            rule_type: Type of rule (e.g., price_level, percentage_change, volatility)
            config: Configuration dictionary for this rule
        """
        self.symbol = symbol
        self.rule_type = rule_type
        self.rule_id = f"{rule_type}_{uuid.uuid4().hex[:8]}"  # Generate a unique ID
        self.config = config
        self.cooldown_seconds = config.get('cooldown', 300)  # Default 5 minutes
    
    @abstractmethod
    def evaluate(self, current_price: float, state_manager, extra_data=None) -> Optional[str]:
        """
        Evaluate if the rule should trigger an alert
        
        Args:
            current_price: Current price of the symbol
            state_manager: StateManager instance to check/update rule state
            extra_data: Any additional data needed for evaluation (e.g., OHLCV candles)
            
        Returns:
            Alert message if rule triggers, None otherwise
        """
        pass
    
    def format_price(self, price: float) -> str:
        """Format price with appropriate precision"""
        # This is just a placeholder - should be improved based on symbol's precision
        if abs(price) > 0 and abs(price) < 0.001:  # Very small prices
            return f"{price:.8f}"
        return f"{price:.2f}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(symbol={self.symbol}, id={self.rule_id})" 

